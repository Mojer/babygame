<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>CUTE RUN！可愛田徑賽</title>
  <style>
    :root{ --bg:#f9fbff; --ink:#1d2b3a; --mint:#b8f1e2; --violet:#dcd0ff; --accent:#7c6cff; --shadow:0 8px 24px rgba(0,0,0,.12); }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#eef5ff);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif}
    #app{display:grid;place-items:center;min-height:100dvh;padding:8px}
    .card{width:100%;max-width:960px;background:white;border-radius:24px;box-shadow:var(--shadow);overflow:hidden;border:2px solid #edf1ff}
    header{padding:12px 16px;display:flex;align-items:center;gap:12px;background:linear-gradient(90deg,var(--mint),var(--violet));border-bottom:2px solid #e7ecff}
    header h1{font-size:18px;margin:0;letter-spacing:.5px;display:flex;align-items:center;gap:8px}
    header .tag{margin-left:auto;background:var(--ink);color:white;padding:4px 8px;border-radius:999px;font-size:12px}

    .wrap{display:grid;grid-template-columns:1fr;gap:8px;padding:8px}
    #ui{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button, .pill{cursor:pointer;border:0;padding:8px 12px;border-radius:14px;background:var(--ink);color:#fff;box-shadow:var(--shadow);font-weight:700}
    button.secondary{background:#fff;color:var(--ink);border:2px solid #dfe7ff}
    button.ghost{background:transparent;color:var(--ink);border:2px dashed #c7cff7}
    .pill{background:var(--accent)}
    .grow{flex:1}

    canvas{width:100%;height:auto;aspect-ratio:16/9;background:linear-gradient(180deg,#c7ecff 0 45%, #eafff2 45%);border-radius:18px;border:2px solid #e7ecff;touch-action:none}
    canvas.no-ar{aspect-ratio:auto}
    #gameWrap{position:relative}

    .mobile-ctrls{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin:8px 0}
    .btn{user-select:none;-webkit-user-select:none;touch-action:manipulation;text-align:center;padding:14px 8px;border-radius:14px;font-weight:800;font-size:18px;background:linear-gradient(180deg,#ffffff,#f2f5ff);border:2px solid #dfe7ff;box-shadow:var(--shadow)}
    .btn:active{transform:translateY(1px)}

    @media (max-width: 900px){
      .card{max-width:none;border-radius:16px}
      .wrap{gap:0}
      .mobile-ctrls{position:static;margin:8px 0;padding-bottom:calc(8px + env(safe-area-inset-bottom))}
      canvas.fullheight{height:auto;border-radius:0}
    }

    .overlay{position:absolute;inset:0;display:grid;place-items:center}
    .panel{background:white;border:2px solid #e7ecff;border-radius:20px;box-shadow:var(--shadow);padding:14px;max-width:560px;margin:8px}
    .title{font-size:24px;margin:0 0 8px}
    .center{display:grid;place-items:center;gap:8px}

    .bar{height:10px;background:#eef2ff;border:2px solid #dfe7ff;border-radius:999px;overflow:hidden}
    .bar > span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#88e0ff);width:0%}

    .rotate-hint{position:fixed;inset:0;display:none;place-items:center;background:rgba(255,255,255,.92);backdrop-filter:saturate(120%) blur(4px);z-index:50}
    .rotate-hint .panel{max-width:360px}
    @media (orientation:portrait) and (max-width:900px){ .rotate-hint{display:grid} }
  </style>
</head>
<body>
<div class="rotate-hint"><div class="panel center"><h3 class="title">📱 建議橫向遊玩</h3><div>可直接開始，稍後即可替換素材。</div><button id="btnIgnoreRotate" class="secondary" style="margin-top:8px">我知道了，繼續</button></div></div>
<div id="app">
  <div class="card">
    <header>
      <h1>🏃‍♀️ CUTE RUN！可愛田徑賽</h1>
      <span class="tag">HTML 單檔 · 自訂 4 角色圖片</span>
    </header>

    <div class="wrap">
      <div id="gameWrap">
        <canvas id="game"></canvas>
        <div id="startOverlay" class="overlay">
          <div class="panel center">
            <h2 class="title">準備，預備——<span style="color:var(--accent)">衝！</span></h2>
            <div class="bar" style="width:100%"><span id="countBar"></span></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
              <button id="btnStart" type="button">開始比賽</button>
              <button id="btnHow" class="secondary" type="button">玩法說明</button>
              <button id="btnFull" class="ghost" type="button">全螢幕</button>
            </div>
          </div>
        </div>
        <div id="finishOverlay" class="overlay" style="display:none">
          <div class="panel center">
            <h2 class="title" id="finishTitle">完成！</h2>
            <div id="finishStats"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnRestart" type="button">再跑一場</button>
              <button id="btnShare" class="secondary" type="button">截圖分享</button>
            </div>
          </div>
        </div>
      </div>

      <div id="ui">
        <div class="pill" id="status">距離：0m｜時間：0.0s｜名次：—</div>
        <div class="grow"></div>
        <button id="btnPause" class="ghost" type="button">暫停</button>
        <button id="btnMute" class="ghost" type="button">🔊</button>
      </div>

      <div class="mobile-ctrls" id="mobileCtrls">
        <div class="btn" data-act="left">左</div>
        <div class="btn" data-act="jump">跳</div>
        <div class="btn" data-act="right">右</div>
      </div>
    </div>
  </div>
</div>

<script>
(()=>{
  const CONFIG = { trackLength:400, lanes:4, laneHeight:124, worldScale:2.0, obstaclesPer100m:1.2, aiBaseSpeed:4.2, aiRubberBand:0.0035, playerBaseSpeed:3.8, playerBoost:1.25, playerPenalty:-1.1, speedFriction:0.96, jumpVel:10.5, gravity:0.65, bgParallax:0.25 };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const isMobile = ()=> window.innerWidth <= 900;

  let W=0, H=0, TRACK_TOP=0;
  function recomputeLayout(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width || canvas.clientWidth || window.innerWidth || 960;

    const vh = window.visualViewport?.height || window.innerHeight || rect.height || 540;
    let cssH;
    if(isMobile()){
      canvas.classList.add('no-ar');
      const headerH = document.querySelector('header')?.getBoundingClientRect().height || 0;
      const uiH     = document.getElementById('ui')?.getBoundingClientRect().height || 0;
      const ctrlsH  = document.getElementById('mobileCtrls')?.getBoundingClientRect().height || 0;
      const paddings= 24;
      cssH = Math.max(220, vh - headerH - uiH - ctrlsH - paddings);
    }else{
      canvas.classList.remove('no-ar');
      cssH = cssW*9/16;
    }

    canvas.style.height = cssH + 'px';

    const dprW = Math.floor(cssW * dpr);
    const dprH = Math.floor(cssH * dpr);
    if(canvas.width!==dprW) canvas.width = dprW;
    if(canvas.height!==dprH) canvas.height = dprH;
    W=canvas.width; H=canvas.height;
    TRACK_TOP = Math.max(48, Math.floor((H - CONFIG.lanes*CONFIG.laneHeight)/2));
  }
  window.addEventListener('resize', recomputeLayout);
  window.visualViewport?.addEventListener('resize', recomputeLayout);
  recomputeLayout();

  const uiStatus = document.getElementById('status');
  const btnPause = document.getElementById('btnPause');
  const btnMute = document.getElementById('btnMute');
  const btnStart = document.getElementById('btnStart');
  const btnHow = document.getElementById('btnHow');
  const startOv = document.getElementById('startOverlay');
  const finishOv = document.getElementById('finishOverlay');
  const finishTitle = document.getElementById('finishTitle');
  const finishStats = document.getElementById('finishStats');
  const btnRestart = document.getElementById('btnRestart');
  const btnShare = document.getElementById('btnShare');
  const mobileCtrls = document.getElementById('mobileCtrls');
  const btnFull = document.getElementById('btnFull');
  const rotateHint = document.querySelector('.rotate-hint');
  const btnIgnoreRotate = document.getElementById('btnIgnoreRotate');

  let gameState='ready', elapsed=0, distance=0, ranking='-';
  let muted=false;

  let actx=null; try{ const AC=window.AudioContext||window.webkitAudioContext; if(AC) actx=new AC(); }catch(_){}
  function resumeAudio(){ if(actx&&actx.state==='suspended') actx.resume(); window.removeEventListener('pointerdown',resumeAudio); }
  window.addEventListener('pointerdown', resumeAudio, {passive:true});
  function beep(f=880,d=0.08,v=0.04){ if(muted||!actx) return; try{ const t=actx.currentTime; const o=actx.createOscillator(); const g=actx.createGain(); o.type='sine'; o.frequency.value=f; g.gain.setValueAtTime(v,t); g.gain.exponentialRampToValueAtTime(0.0001,t+d); o.connect(g).connect(actx.destination); o.start(); o.stop(t+d);}catch(_){}}

  const Images = new Map();
  function loadImage(url){ return new Promise((res,rej)=>{ if(!url) return res(null); if(Images.has(url)) return res(Images.get(url)); const img=new Image(); img.crossOrigin='anonymous'; img.onload=()=>{Images.set(url,img);res(img)}; img.onerror=rej; img.src=url; }); }

  // 你的四張角色圖片（可直接改 URL）
  const runnerImages = [
    'https://i.imgur.com/juEnPa4.png', // 玩家
    'https://i.imgur.com/Wwiq6CU.png', // NPC1
    'https://i.imgur.com/NbNVPKA.png', // NPC2
    'https://i.imgur.com/YOaMEC9.png'  // NPC3
  ];

  const colors=['#ffb7c5','#b3e5fc','#c8e6c9','#fff59d'];
  const mascots=['你','🐰','🐼','🦊'];
  const laneBase = (i)=> TRACK_TOP + (i+1)*CONFIG.laneHeight - 12;

  function createRunner(i,isPlayer=false,img){
    return { id:i,isPlayer,name:(isPlayer?'你':mascots[i%mascots.length]), x:40, y:laneBase(i), vy:0, onGround:true,
      speed:isPlayer?CONFIG.playerBaseSpeed:CONFIG.aiBaseSpeed*(0.9+Math.random()*0.2), boost:0, dirLast:null,
      dist:0, finished:false, finishTime:null, color:colors[i%colors.length], img, scale:1.35, offsetY:10 };
  }
  let runners=[];

  const obstacles=[]; function spawnObstacles(){ const n=Math.max(1,Math.floor(CONFIG.trackLength/100*CONFIG.obstaclesPer100m)); obstacles.length=0; for(let i=0;i<n;i++){ const at=60+Math.random()*(CONFIG.trackLength-100); const lane=Math.floor(Math.random()*CONFIG.lanes); obstacles.push({m:at,lane,w:22,h:24,hit:false}); } obstacles.sort((a,b)=>a.m-b.m);} spawnObstacles();

  function altBoost(side){ const p=runners[0]; if(p.finished) return; if(p.dirLast&&p.dirLast===side){ p.boost+=CONFIG.playerPenalty; beep(220,0.05,0.03);} else { p.boost+=CONFIG.playerBoost; beep(880,0.05,0.04);} p.dirLast=side; }
  function tryJump(r){ if(r.onGround){ r.vy=-CONFIG.jumpVel; r.onGround=false; beep(660,0.07,0.045);} }
  window.addEventListener('keydown', (e)=>{ if(['ArrowLeft','ArrowRight','ArrowUp',' '].includes(e.key)) e.preventDefault(); if(e.key==='ArrowLeft') altBoost('L'); if(e.key==='ArrowRight') altBoost('R'); if(e.key==='ArrowUp'||e.key===' ') tryJump(runners[0]); });
  mobileCtrls.addEventListener('touchstart', (e)=>{ const t=e.target.closest('.btn'); if(!t) return; const a=t.dataset.act; if(a==='left') altBoost('L'); if(a==='right') altBoost('R'); if(a==='jump') tryJump(runners[0]); }, {passive:true});

  function reset(){ elapsed=0; distance=0; ranking='-'; spawnObstacles(); for(let i=0;i<runners.length;i++){ const r=runners[i]; r.x=40; r.vy=0; r.onGround=true; r.boost=0; r.dist=0; r.finished=false; r.finishTime=null; r.dirLast=null; r.y=laneBase(i); r.speed = r.isPlayer? CONFIG.playerBaseSpeed : CONFIG.aiBaseSpeed*(0.9+Math.random()*0.2); } gameState='ready'; startOv.style.display='grid'; finishOv.style.display='none'; btnPause.textContent='暫停'; }
  async function start(){
    rotateHint.style.display='none';
    if(gameState==='running') return;
    gameState='running'; elapsed=0; startOv.style.display='none';
    recomputeLayout();
    last=performance.now(); animate();
  }
  function finish(){ gameState='finished'; const order=[...runners].sort((a,b)=> (a.finishTime??1e9)-(b.finishTime??1e9)); const rank=order.findIndex(r=>r.isPlayer)+1; finishTitle.textContent = rank===1? '🥇 你是第一名！' : `完成！第 ${rank} 名`; const my=runners[0]; finishStats.innerHTML = `用時 <b>${(my.finishTime??elapsed).toFixed(2)}s</b>｜總距離 <b>${CONFIG.trackLength}m</b><br/>對手成績：`+ order.map((r,i)=> `${i+1}. ${r.isPlayer? '你' : r.name} — ${(r.finishTime??elapsed).toFixed(2)}s`).join('<br/>'); finishOv.style.display='grid'; beep(520,0.12,0.06); setTimeout(()=>beep(660,0.12,0.06),120); setTimeout(()=>beep(800,0.12,0.06),240); }

  btnStart?.addEventListener('click', start);
  btnHow?.addEventListener('click', ()=>{ alert(`玩法：交替按鍵盤 ← → 加速，↑ 或空白鍵跳躍。\n手機可用下方按鈕。`); });
  btnRestart?.addEventListener('click', ()=>{ reset(); start(); });
  btnShare?.addEventListener('click', ()=>{ const url=canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='cute-run.png'; a.click(); });
  btnPause?.addEventListener('click', ()=>{ if(gameState==='running'){ gameState='paused'; btnPause.textContent='繼續'; } else if(gameState==='paused'){ gameState='running'; btnPause.textContent='暫停'; last=performance.now(); requestAnimationFrame(animate); } });
  btnMute?.addEventListener('click', ()=>{ muted=!muted; btnMute.textContent=muted?'🔇':'🔊'; });
  btnFull?.addEventListener('click', async()=>{ try{ if(!document.fullscreenElement){ await document.documentElement.requestFullscreen?.(); } else { await document.exitFullscreen?.(); } }catch(_){} finally{ recomputeLayout(); } });
  btnIgnoreRotate?.addEventListener('click', ()=>{ document.querySelector('.rotate-hint').style.display='none'; });
  startOv.addEventListener('pointerdown', (e)=>{ if(gameState==='ready' && e.target===startOv) start(); });
  document.addEventListener('fullscreenchange', recomputeLayout);

  function update(dt){ if(gameState!=='running') return; elapsed+=dt; const p=runners[0]; p.speed=(p.speed+p.boost)*CONFIG.speedFriction; p.boost*=0.85; p.speed=Math.max(1.2, Math.min(p.speed, 14)); const lead=Math.max(...runners.map(r=>r.dist)); for(let i=1;i<runners.length;i++){ const r=runners[i]; if(r.finished) continue; const luck=(Math.random()-0.5)*0.12; const gap=(lead-r.dist); r.speed += CONFIG.aiRubberBand*gap + luck; r.speed=Math.max(2.4, Math.min(r.speed, 12)); } for(const r of runners){ if(r.finished) continue; r.dist += r.speed * 0.08 * CONFIG.worldScale; if(r.dist>=CONFIG.trackLength){ r.dist=CONFIG.trackLength; r.finished=true; r.finishTime=elapsed; } r.y += r.vy; r.vy += CONFIG.gravity; if(r.y>=laneBase(r.id)){ r.y=laneBase(r.id); r.vy=0; r.onGround=true; } } for(const o of obstacles){ for(const r of runners){ if(r.finished||r.id!==o.lane||o.hit) continue; const near=Math.abs(r.dist-o.m)<2.2; const low=r.onGround&&r.vy===0; if(near&&low){ r.speed*=0.4; r.dist=Math.max(0,r.dist-1.5); o.hit=true; if(r.isPlayer) beep(180,0.08,0.05); } } } if(runners.every(r=>r.finished)) finish(); const orderNow=[...runners].sort((a,b)=> b.dist-a.dist); const rankNow=orderNow.findIndex(r=>r.isPlayer)+1; ranking=rankNow; distance=runners[0].dist; uiStatus.textContent = `距離：${distance.toFixed(1)}m｜時間：${elapsed.toFixed(1)}s｜名次：${ranking}/${CONFIG.lanes}`; }

  function worldToScreen(m, camX){ const pxPerM=5.4*CONFIG.worldScale; return W*0.2 + m*pxPerM - camX; }

  function drawBackground(camX){
    const skyH = H * 0.45;
    ctx.fillStyle = '#b9e3ff';
    ctx.fillRect(0, 0, W, skyH);

    ctx.fillStyle = 'rgba(255,255,255,0.88)';
    for(let i=0;i<5;i++){
      const off = ((i*300 - camX*(CONFIG.bgParallax*0.2)) % (W+400)) - 200;
      const y = 40 + (i%2)*20;
      ctx.beginPath(); ctx.ellipse(off, y, 50, 20, 0, 0, Math.PI*2);
      ctx.ellipse(off+30, y-10, 40, 15, 0, 0, Math.PI*2);
      ctx.ellipse(off-30, y-10, 40, 15, 0, 0, Math.PI*2);
      ctx.fill();
    }

    const baseYNear = skyH - 18; const baseYFar  = skyH - 32;
    ctx.fillStyle = '#89b7d6';
    for(let i=0;i<6;i++){
      const off = ((i*420 - camX*(CONFIG.bgParallax*0.5)) % (W+520)) - 260;
      ctx.beginPath(); ctx.moveTo(off, baseYFar); ctx.lineTo(off+190, baseYFar-90); ctx.lineTo(off+380, baseYFar); ctx.closePath(); ctx.fill();
    }
    ctx.fillStyle = '#a6d2f9';
    for(let i=0;i<8;i++){
      const off = ((i*300 - camX*(CONFIG.bgParallax*1.0)) % (W+360)) - 180;
      ctx.beginPath(); ctx.moveTo(off, baseYNear); ctx.lineTo(off+140, baseYNear-80); ctx.lineTo(off+280, baseYNear); ctx.closePath(); ctx.fill();
    }

    ctx.fillStyle = '#dff6e5';
    ctx.fillRect(0, skyH, W, H - skyH);
    ctx.fillStyle = 'rgba(130,220,170,.6)';
    ctx.fillRect(0, skyH, W, 30);
  }

  function drawTrack(camX){ const top=TRACK_TOP; const trackH=CONFIG.lanes*CONFIG.laneHeight; ctx.fillStyle='#f7d9ba'; ctx.fillRect(0, top, W, trackH); for(let i=0;i<=CONFIG.lanes;i++){ const y=top + i*CONFIG.laneHeight; ctx.strokeStyle='white'; ctx.lineWidth=4; ctx.setLineDash([16,12]); ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); } ctx.setLineDash([]); ctx.fillStyle='#ffffffaa'; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.textBaseline='top'; for(let m=0;m<=CONFIG.trackLength;m+=50){ const x=worldToScreen(m, camX); if(x<0||x>W) continue; ctx.fillRect(x-1, top, 2, trackH); ctx.fillText(m+'m', x, top+6); } const fx=worldToScreen(CONFIG.trackLength, camX); if(fx>0&&fx<W){ ctx.fillStyle='#fff'; for(let i=0;i<12;i++) ctx.fillRect(fx-2, top+i*10, 4, 6); } }

  function drawRunner(r, camX){
    const x=worldToScreen(r.dist, camX); const y=r.y;
    const img=r.img;
    if(img){
      const dw=img.width * 0.5 * r.scale; // 自動依圖寬縮放
      const dh=img.height* 0.5 * r.scale;
      ctx.drawImage(img, x-dw/2, (y-dh)-r.offsetY, dw, dh);
      if(!r.isPlayer){ ctx.font='20px system-ui'; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillStyle='#222'; ctx.fillText(r.name, x, (y-dh)-r.offsetY-6); }
      return;
    }
    // 後備：若圖片載不到，畫簡單方塊
    ctx.fillStyle=r.color; const w=64,h=42,rad=20; roundRect(ctx, x-w/2, y-h, w, h, rad); ctx.fill();
  }

  function drawObstacles(camX){ for(const o of obstacles){ const x=worldToScreen(o.m, camX), y=laneBase(o.lane)-4; ctx.fillStyle=o.hit?'#cfd8dc':'#ff8a80'; roundRect(ctx, x-12, y-26, 24, 24, 6); ctx.fill(); ctx.fillStyle='#fff'; ctx.fillRect(x-10, y-22, 20, 6); } }
  function roundRect(ctx,x,y,w,h,r){ const rr=Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath(); }

  function render(){
    const pxPerM = 5.4 * CONFIG.worldScale;
    const camX   = (runners[0]?.dist || 0) * pxPerM;
    ctx.clearRect(0,0,W,H);
    drawBackground(camX);
    drawTrack(camX);
    drawObstacles(camX);
    const order=[...runners].sort((a,b)=> a.y-b.y);
    for(const r of order) drawRunner(r, camX);
  }

  let last=performance.now();
  function animate(){ const now=performance.now(); const dt=Math.min(0.05,(now-last)/1000); last=now; if(gameState==='running') update(dt); render(); if(gameState!=='finished') requestAnimationFrame(animate); }
  function idleBar(){ if(gameState!=='ready') return; const t=(Math.sin(performance.now()/600)+1)/2; countBar.style.width=(8+t*84)+'%'; requestAnimationFrame(idleBar); }

  function selfTest(){
    try{
      console.groupCollapsed('%cCUTE RUN 自檢','color:#7c6cff;font-weight:700');
      const camA=0, camB=100; const a=worldToScreen(10, camA), b=worldToScreen(10, camB);
      console.assert(a-b===100, 'worldToScreen 應隨 camX 差值線性遞減');
      console.assert(W>0 && H>0, '畫布像素大小需>0');
      const y0=laneBase(0), y3=laneBase(3); console.assert(y0<y3 && y3<=H, '跑道垂直位置需在畫面內');
      console.assert(runners[0]?.isPlayer===true, '第 1 跑者需為玩家');
      console.assert(obstacles.length>0 && obstacles.every((_,i,arr)=> i===0 || arr[i-1].m<=arr[i].m), '障礙需存在且已排序');
      console.log('✅ 自檢通過'); console.groupEnd();
    }catch(e){ console.error('❌ 自檢失敗', e); }
  }

  (async()=>{
    idleBar();
    const imgs = await Promise.all(runnerImages.map(loadImage));
    runners = imgs.map((img, i)=> createRunner(i, i===0, img));
    reset();
    selfTest();
  })();
})();
</script>
</body>
</html>